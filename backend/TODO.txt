Backend-Retriever:

    - Write down the schemas for: conversation, domain, email, envelope, settings, user, userrule

    - Function to create and populate a DB por unittesting

    - Dont insert messages already on the DB (check everything after parsing).

    - Think about what to do with messages without Message-ID field

    - When the message failed to enter (validation error, or error on save) generate a rebound
      using our message sending system (when implemented)

    - Convert main.d to a class? and db.d?

    - Install and configure the indexer

    - Make the retriever index a copy of the message

    - main.d: configure DB name and connection data from a config file

    - Exception classes for the different parts (and use them)

    - Const, immutable, pure, nothrow, in, out, safe et all

    - Initial configuration script

    - Retriever's full test, use a Python script with the mail & smtp modules to parse
      the test mails collection changing the receiver from [myRealAddr] to [mongoTestAddr]
      before delivering to Postfix, create a MongoDB database "webmailtest", populate it,
      check that we receive every email, check that that the isValidAddress check is fine,
      check that the filters of the test DB apply correctly

    - Sent the new changes in characterencodings.d to ruppe

    - See how to get around Mongo's 16MB document limit (GridFS?) Check is some email of my
      collection is bigger than 16MB without attachments

    - Term unification: 
            "id" at the end of start? 
            mail or email? 
            save or serialize? 
            forwardedTo, doForward...
            message-id (email document), messageId, idMessage

Backend-API:

Frontend:
