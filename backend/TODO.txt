Backend-API:
    - /tag?name="inbox"&limit=50: 
        - Return the conversations with these parameters: 
         cursor = db.conversation.find({"tags": {"$in": ["inbox"]}}).sort({lastDate: -1})
        - Generate the Conversation with the MessageSummaries, subject, etc.

    - Const, immutable, pure, nothrow, in, out, safe et all

Backend-Retriever:
    - Envelope.asJsonString and use it on db.d

    - Conversation.updateLastDate => validate the date!

    - Privatize IncomingEmail and interface

    - Mongo DB indexes, ensure()

    - import only the symbols really used

    - When the message failed to enter (validation error, or error on save)
      generate a rebound using our message sending system (when implemented)

    - Exception classes for the different parts (and use them)

    - Retriever's full test, use a Python script with the mail & smtp modules to
      parse the test mails collection changing the receiver from [myRealAddr] to
      [mongoTestAddr] before delivering to Postfix, create a MongoDB database
      "webmailtest", populate it, check that we receive every email, check that
      that the isValidAddress check is fine, check that the filters of the test DB
      apply correctly, check searches with the indexer, et cetera.

    - Const, immutable, pure, nothrow, in, out, safe et all

    - Sent the new changes in characterencodings.d to Ruppe

    - See how to get around Mongo's 16MB document limit for bigger emails
      (GridFS?) Check is some email of my collection is bigger than 16MB without
      attachments (=> no)



Frontend:

Installation/Configuration system:
